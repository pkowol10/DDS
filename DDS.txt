wadr = 32
wdata = 64
wmem = 2^12
akumulator fazy[wadr-1:0](krok[wadr-1:0]) -> adres[wadr-1:0]
pamiec[wmem-1:0][wdata-1:0](adres[wadr-1:wadr-12]) -> data[wdata-1:0]

ser_64_8(data[wdata-1:0]-uwaga na kolejnosc danych!!!)

miedzy ser_64_8 a pamiecia mux_8_1 x64 + reg_64 (8 odpowiadajacych sobie bitow z pamieci do jendego wejscia sera)

sterowanie muxami:
jesli krok jest maly, to na podstawie jego mlodszych bitow sterowac, a jesli krok jest duzy na tyle, ze
za kazdym razem jest ladowana kolejna komorka pamieci, to muxy beda przekazywac co druga lub co czwarta probke??? 
(albo ta czesc olac i po prostu przekazywac ta sama do kilku serow lub po kolei - mozna zalozyc maksymalny krok taki, by
odczytywac za kazdym razem kolejna probke z pamieci)



BUFR(2) -> 0.264 ns opoznienia
BUFR(1) -> nie dziala
BUFR(BYPASS) -> 0.769 ns opoznienia



PA_comp:
step	f
200	762.744
120	443.262
110	405.844
100	369.822

dla sumatora dane nie sa powiazane z krokiem fazowym


mod	f
250	932.835
240	932.835
200	1506.024



- rezygnacja z BUFR, bo PLL ma 6 kanalow
- phase acumulator - adder czy counter - wyniki pomiarów (preferencja: adder, oba uklady wyrabiaja czasowo (16-bit, 24 nie 
powinny byc problemem - CSA 2x8bit, RCA 16-bit, CNT-16bit))
- multipleksacja danych pamiec-serdes (liniowosc fazy)
- timing report - OSERDESE2 oraz PLL_BASEE2 wyrabiaja, ale BUFG na wysjciu PLLa ma przekroczenie minimalnego okresu o 0.155 ns - 
czy to ma duze znaczenie (T_min = 2.155 ns, co odpowiada f_max = 464 MHz)? Rozwaizanie: obnizenie czestotliwosci HS_CLK do 
450 MHz (LS_CLK do 112.5 MHz)
- power report - estymacja zuzycia mocy oraz temperatury ukladu - na ile pokrywa sie z rzeczywistoscia? (na wszelki wypadek, 
kryzys energetyczny zazegnany przez konfiguracje zegara w .xdc)

komendy:

LOAD - przejscie do trybu ladowania danych
STEP - zaladowanie kroku fazowego
GENE - przejscie do trybu generowania sygnału
BIST - przejscie do trybu testowania (po tescie automatyczne wyslanie wyniku pass/all + zapytanie o raport (y/n))
STOP - zatrzymanie pracy ukladu
RESE - software'owy reset DDS'a (RESET wyprowadzic tez na przycisk !!!)


#define SAMPLES 8192
#define SAMPLE_LEN 8
#define SAMPLE_CHAR_LEN 3

char8 command[SAMPLE_CHAR_LEN + 1];

void load_step() {
u32 ret;
char8 c;
    outbyte ( c = inbyte() );
    ret = 10000 * (c - '0');
    outbyte ( c = inbyte() );
    ret = 1000 * (c - '0');
    outbyte ( c = inbyte() );
    ret = 100 * (c - '0');
    outbyte ( c = inbyte() );
    ret = 10 * (c - '0');
    outbyte ( c = inbyte() );
    ret = (c - '0');


}

u32 read_sample() {
u32 ret;
char8 c;
    outbyte ( c = inbyte() );
    ret += 100 * (c - '0');
    outbyte ( c = inbyte() );
    ret += 10 * (c - '0');
    outbyte ( c = inbyte() );
    ret += (c - '0');
    return ret;
}

void load_data() {
    u32 buf_high = 0;
    u32 buf_low = 0;
    u32 sample;
    for (u32 j = 0; j < SAMPLES/SAMPLE_LEN; j = j + 1) {
        for (u32 i = 0; i < 7; i = i + 1) {
            sample = read_sample();
            if (i < 4) {
                buf_low += (sample << i*8);
            }
            else {
                buf_high += (sample << (i - 4)*8);
            }
        }
    
    }
}

void read_command() {
    outbyte ( c = inbyte() );
    command[0] = c;
    outbyte ( c = inbyte() );
    command[1] = c;
    outbyte ( c = inbyte() );
    command[2] = c;
    outbyte ( c = inbyte() );
    command[3] = c;
}

void command() {
    command[4] = '\0';
    read_command();
    if (command[0] == 'l' && command[1] == 'o' && command[2] == 'a' && command[3] == 'd') {
        load_data();
    } else if (command[0] == 's' && command[1] == 't' && command[2] == 'e' && command[3] == 'p') {
        load_step();
        // step 
    } else if (command[0] == 'g' && command[1] == 'e' && command[2] == 'n' && command[3] == 'e') {
        // gene
    } else if (command[0] == 'b' && command[1] == 'i' && command[2] == 's' && command[3] == 't') {
        // bist
    } else if (command[0] == 's' && command[1] == 't' && command[2] == 'o' && command[3] == 'p') {
        // stop
    } else if (command[0] == 'r' && command[1] == 'e' && command[2] == 's' && command[3] == 'e') {
        // rese
    }
}

int main () {
    while (true) {
        command();
    }
}